import React from "react";
import { Switch, Route, useRouteMatch, Redirect } from "react-router";
import { ObjectEntries, ObjectKeys } from "./util";
import { useGenEffect } from "./hooks";
import { Link } from "react-router-dom";
import resolvePathname from "resolve-pathname";

/**
 * debugging purposes, returns a `<pre>` with the stringified props.
 */
export function Expose(props: any) {
    return <pre>{JSON.stringify(props, undefined, 3)}</pre>;
}

interface StylesheetProps {
    /**
     * mapping of selector to CSSProperties
     * like {".SideMenu": {backgroundColor: "red"}} would style components with the "SideMenu" className to have red background.
     */
    styles: Record<string, React.CSSProperties>;
}
function parseOneStyle(selector: string, style: React.CSSProperties) {
    let code = "";
    for (const [field, value] of ObjectEntries(style)) {
        code += camelToDash(field) + ":" + value + ";";
    }
    return `${selector} {${code}}`;
}
function camelToDash(str: string) {
    return str.replace(/\W+/g, "-").replace(/([a-z\d])([A-Z])/g, "$1-$2");
}
/** JSX component that resolves to a `<style>` tag, uses react syntax for styling. */
export function Stylesheet({ styles }: StylesheetProps) {
    let code = ObjectEntries(styles)
        .map((a) => parseOneStyle(...a))
        .join("\n");
    return <style>{code}</style>;
}

function* withClassName<HTMLElem extends { classList: DOMTokenList } = HTMLElement>(
    elem: HTMLElem | null,
    classname: string,
) {
    yield arguments;
    if (elem === null) return;
    elem.classList.add(...classname.split(" "));
    yield;
    elem.classList.remove(...classname.split(" "));
}
interface MainProps extends React.PropsWithChildren<{}> {
    /** styles to apply to the main tag directly inside body */
    style?: React.CSSProperties;
    /** className to apply to the main tag directly inside body */
    className: string;
}
/**
 * applies styles to the main top level component.
 * all top level route based components should wrap contents around this.
 */
export function Main({ children, style, className }: MainProps) {
    const stylesheet = style === undefined ? null : <Stylesheet styles={{ "body>main": style }} />;
    useGenEffect(withClassName(document.getElementById("root"), className));

    return (
        <React.Fragment>
            {children}
            {stylesheet}
        </React.Fragment>
    );
}

/**
 * trims leading and trailing slashes in given string
 */
function trimSlashes(str: string) {
    return str.replace(/^\/+/, "").replace(/\/+$/, "");
}
/**
 * list of links to given paths.
 * is a Main component usign class "index" so it is intended to always put this at the top level
 */
export function IndexPage(props: { paths: string[] }) {
    return (
        <Main className="index">
            <ul>
                {props.paths.map((path) => (
                    <li key={path}>
                        <Link to={path}>{trimSlashes(path)}</Link>
                    </li>
                ))}
            </ul>
        </Main>
    );
}
/**
 * generates routes for makeCompSwitch
 * includes optional redirects for all routes that end in / in order to ensure they work as expected
 * in the event of not trailing /.
 *
 * Have run into annoying issues where links break when strict is not used
 * but strict makes just missing the trailing / completely fail, so adding these redirects is the best solution.
 */
function* generateRoutes(paths: Array<[string, React.ComponentType]>) {
    for (const [path, comp] of paths) {
        if (path.endsWith("/")) {
            // if the given path ends with / then redirect the version without slash to trailing slash
            yield (
                <Redirect
                    key={path + "fix"}
                    strict
                    exact
                    from={path.replace(/\/+$/, "")}
                    to={path}
                />
            );
        }
        yield (<Route key={path + "route"} strict path={path} component={comp} />);
    }
}
/**
 * returns a react component to map the given paths to a route and index page.
 * @param paths map of string link to react component for that path.
 */
export function makeCompSwitch<K extends string>(paths: Record<K, React.ComponentType<{}>>) {
    return function AutoGeneratedRouteSwitch() {
        const fallback = <p>404 page not found</p>;

        return (
            <RelSwitch>
                <Route path={"."} exact>
                    <IndexPage paths={ObjectKeys(paths)} />
                </Route>
                {[...generateRoutes(ObjectEntries(paths))]}
                <Route>{fallback}</Route>
            </RelSwitch>
        );
    };
}

/**
 * mostly stolen from https://github.com/carloluis/use-media-query-hook/blob/master/index.js
 */
export function useMediaQuery(queryString: string) {
    const [queryMatch, dispatchUpdate] = React.useReducer(
        (prev: boolean, e: MediaQueryList | MediaQueryListEvent) => e.matches,
        undefined,
        () => window.matchMedia(queryString).matches,
    );
    useGenEffect(updateQuery());
    function* updateQuery() {
        yield [queryString];
        const e = window.matchMedia(queryString);
        dispatchUpdate(e);
        e.addListener(dispatchUpdate);
        yield;
        e.removeListener(dispatchUpdate);
    }
    return queryMatch;
}
/**
 * react lazy component that will never resolve
 * can be used when waiting on async call to hide up to suspense.
 */
export const Unrenderable = React.lazy(() => new Promise(() => {}));
/**
 * wrapper for react-router Switch
 * replaces the `path` prop (and `to` and `from` for redirects) to be relative to the current match
 * so paths that begin with `/` will still be absolute, but otherwise paths like `./test` or just `test`
 * will be relative to the part of url already consumed by parent routes.
 */
export function RelSwitch({ children }: React.PropsWithChildren<{}>) {
    const { path: basePath } = useRouteMatch();
    return (
        <Switch>
            {React.Children.map(children, (child) => {
                if (!React.isValidElement(child)) {
                    return child;
                }
                const { path, from, to } = child.props;
                const newProps: { path?: string; from?: string; to?: string } = {};
                if (path !== undefined) {
                    newProps.path = resolvePathname(path, basePath);
                }
                if (from !== undefined) {
                    newProps.from = resolvePathname(from, basePath);
                }
                if (to !== undefined) {
                    newProps.to = resolvePathname(to, basePath);
                }
                return React.cloneElement(child, newProps);
            })}
        </Switch>
    );
}
